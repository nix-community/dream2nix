import os
import shutil
from pathlib import Path
from typing import Any, Optional, TypedDict

from .config import root
from .dependencies import Dependency, DepsTree, get_all_deps, recurse_deps_tree
from .logger import logger
from .derivation import InstallMethod, get_install_method, get_self
from .package import (
    NodeModulesPackage,
    NodeModulesTree,
    create_binary,
    get_all_deps_tree,
    get_bins,
    get_node_modules_tree,
    get_package_json,
)


def _create_package_from_derivation(
    dep: Dependency,
    path: Path,
):
    node_modules = root / path
    target = node_modules / Path(dep.name)
    bin_dir = node_modules / Path(".bin")

    target.parent.mkdir(parents=True, exist_ok=True)
    install_method = get_install_method()

    if not get_package_json(Path(dep.derivation)):
        logger.debug(f"{str(dep)} is not a package. Skipping installation")
        return
    # check if there is already the right package installed
    # folder might be created, but package.json only when installed
    if not (target / Path("package.json")).exists():
        if install_method == InstallMethod.copy:
            target.mkdir(parents=True, exist_ok=True)
            for entry in os.listdir(dep.derivation):
                if (dep.derivation / Path(entry)).is_dir():
                    shutil.copytree(
                        dep.derivation / Path(entry),
                        target / Path(entry),
                        dirs_exist_ok=True,
                    )
                else:
                    shutil.copy(dep.derivation / Path(entry), target / Path(entry))

            os.system(f"chmod -R +w {target}")
        elif install_method == InstallMethod.symlink:
            target.mkdir(parents=True, exist_ok=True)
            for entry in os.listdir(dep.derivation):
                if not (target / Path(entry)).exists():
                    (target / Path(entry)).symlink_to(dep.derivation / Path(entry))
                else:
                    logger.info(
                        f"skipping: file {(target / Path(entry))} already exists."
                    )

        binaries = get_bins(dep)
        for name, rel_path in binaries.items():
            create_binary(bin_dir / Path(name), Path(dep.name) / rel_path)


class Passthrough(TypedDict):
    """
    Wrapper class
    Holds global information during recursion in <_make_folders_rec>
    """

    all_deps: dict[str, Dependency]
    flat_deps: list[str]


def _make_folders_rec(
    node_modules_tree: NodeModulesTree,
    passthrough: Passthrough,
    path: Path = Path(""),
):
    """
    Builds the node_modules folder structure
    from the NodeModulesTree datastructures
    """
    name: str
    meta: NodeModulesPackage

    for name, meta in node_modules_tree.items():

        version = meta["version"]
        dependencies: Optional[NodeModulesTree] = meta.get("dependencies", None)
        found_dependency = passthrough["all_deps"].get(f"{name}@{version}")

        if found_dependency:
            source = found_dependency.derivation
            dep = Dependency(
                name,
                version,
                source,
                dependencies=dependencies,
            )

            if dependencies:
                _make_folders_rec(
                    node_modules_tree=dependencies,
                    passthrough=passthrough,
                    path=path / Path(f"{name}/node_modules"),
                )

            _create_package_from_derivation(
                dep,
                path,
            )
        else:

            if f"{name}@{version}" in passthrough["flat_deps"]:
                logger.critical(f"{name}@{version} required but not found")


def create_node_modules():
    def collect_dependency(
        accumulator: Any, dep: Dependency, dep_tree: Optional[DepsTree]
    ) -> Any:
        identifier = str(dep)
        if identifier not in accumulator.keys():
            accumulator[identifier] = dep
        return accumulator

    nm_tree = get_node_modules_tree()
    all_deps = get_all_deps_tree()

    collected: dict[str, Dependency] = recurse_deps_tree(
        all_deps, collect_dependency, accumulator={}
    )
    root_pkg = get_self()
    flat_deps: list[str] = get_all_deps(all_deps, root_pkg.name, root_pkg.version)

    _make_folders_rec(
        nm_tree,
        passthrough={"all_deps": collected, "flat_deps": flat_deps},
    )
